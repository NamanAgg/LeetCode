//*************924. Minimize Malware Spread
// You are given a network of n nodes represented as an n x n adjacency matrix graph,
// where the ith node is directly connected to the jth node if graph[i][j] == 1.
// Some nodes initial are initially infected by malware. Whenever two nodes are directly connected,
// and at least one of those two nodes is infected by malware, both nodes will be infected by malware.
// This spread of malware will continue until no more nodes can be infected in this manner.
// Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.
// We will remove exactly one node from initial.
// Return the node that, if removed, would minimize M(initial).
// If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
// Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.

// Example 1:
// Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
// Output: 0

// Example 2:
// Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
// Output: 0

// Example 3:
// Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
// Output: 1

// Constraints:
// n == graph.length
// n == graph[i].length
// 2 <= n <= 300
// graph[i][j] is 0 or 1.
// graph[i][j] == graph[j][i]
// graph[i][i] == 1
// 1 <= initial.length <= n
// 0 <= initial[i] <= n - 1
// All the integers in initial are unique.
public class MinimizeMalwareSpread{
    int[]par;
    int[]pop;//population of components
    int[]ipc;//infected people count in components
    
    public int findPar(int u){
       return par[u]==u?u:(par[u]=findPar(par[u]));
    }
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N=graph.length;
        par=new int[N];
        pop=new int[N];
        for(int i=0;i<N;i++){
            par[i]=i;
            pop[i]=1;
        }
        
        for(int i=0;i<N;i++)
            for(int j=0;j<N;j++)
                if(graph[i][j]==1){
                    int p1=findPar(i);
                    int p2=findPar(j);
                    if(p1!=p2){
                        par[p2]=p1;
                        pop[p1]+=pop[p2];
                    }
                }
        
        ipc=new int[N];
        for(int i=0;i<initial.length;i++){
            int par=findPar(initial[i]);
            ipc[par]++;
        }
        
        Arrays.sort(initial);
        int ans=initial[0];
        int maxPop=0;
        for(int i=0;i<initial.length;i++){
            int par=findPar(initial[i]);
            if(ipc[par]==1 && pop[par]>maxPop){
                maxPop=pop[par];
                ans=initial[i];
            }
        }
        return ans;
    }
}